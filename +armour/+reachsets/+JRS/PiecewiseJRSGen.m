classdef PiecewiseJRSGen < armour.reachsets.JRS.OnlineGeneratorBase
% Online reachable set generator for the piecewise trajectory
%
% This class generates the reachable set for a piecewise trajectory. The
% trajectory is generated by taking the current state of the robot and
% planning a trajectory to a goal state. The trajectory is then split into
% two parts, the first part is the acceleration phase and the second part
% is the braking phase. The reachable set is then generated for the
% trajectory.
%
% This is built on top of the OnlineGeneratorBase class.
%
% This incorporates methods previously found in create_jrs_online.m written
% by Patrick Holmes for ARMOUR. This class is a re-write of that code and
% and extension of the functionality provided by it.
%
% --- More Info ---
% Author: Adam Li (adamli@umich.edu)
% Written: 2023-09-22
% Updated: 2023-10-04 (Adam Li)
%
% See also: armour.reachsets.JRS.OnlineGeneratorBase,
% armour.reachsets.JRS.JRSInstance
%
% --- More Info ---
%

    methods (Access=protected)
        function reachableSet = generateReachableSet(self, robotState)
            % Generate the joint reachable set
            %
            % Arguments:
            %   robotState (rtd.entity.states.ArmRobotStateInstance): The
            %       robot state to generate the reachable set for.
            %
            % Returns:
            %   reachableSet (struct): A struct array containing the
            %       reachable set for the robot state provided, where
            %       reachableSet.rs is the reachable set and
            %       reachableSet.id is the id of the reachable set.
            %
            arguments
                self
                robotState(1,1) rtd.entity.states.ArmRobotStateInstance
            end
            
            self.vdisp("Generating joint reachable set!", "INFO")
            
            % Get the range that the parameters should cover
            % Overwriting the parameter range for the piecewise trajectory
            param_range = min(max(pi/24, abs(robotState.velocity/3)), pi/3);
            param_range = [self.param_center - param_range, self.param_center + param_range];

            % Create the reference trajectory
            self.vdisp("Creating Reference Trajectory!", "DEBUG")
            [q_ref, qd_ref, qdd_ref] = genPiecewiseTrajectory( ...
                robotState.position, ...
                robotState.velocity, ...
                self.tplan, ...
                self.tfinal, ...
                self.param_zonos, ...
                param_range, ...
                self.time_zonos);

            % Create the JRS instance from this trajectory
            jrs = self.createInstanceFromReference(q_ref, qd_ref, qdd_ref);
            jrs.setParamRange(param_range);
            jrs.setTrajName('piecewise');

            % Outputs
            reachableSet.rs = jrs;
            reachableSet.id = 1;
        end
    end
end

function [q_ref, qd_ref, qdd_ref] = genPiecewiseTrajectory(q0, qd0, tplan, tfinal, base_params, param_range, time_zonos)
% Generate a piecewise trajectory
%
% This function generates a piecewise trajectory. The trajectory is
% generated by taking the current state of the robot and planning a
% trajectory to a goal state. The trajectory is then split into two parts,
% the first part is the acceleration phase and the second part is the
% braking phase.
%
% Arguments:
%   q0 (double): The initial joint positions.
%   qd0 (double): The initial joint velocities.
%   tplan (double): The time to accelerate for.
%   tfinal (double): The final time of the trajectory and when it should be stopped.
%   base_params (cell): The base parameters for the trajectory.
%   param_range (double): The range that the parameters should cover.
%   time_zonos (cell): The time zonotopes to generate the trajectory for.
%
% Returns:
%   q_ref (cell): The reference position trajectory as n_t x n_q.
%   qd_ref (cell): The reference velocity trajectory as n_t x n_q.
%   qdd_ref (cell): The reference acceleration trajectory as n_t x n_q.
%
    arguments
        q0(:,1) double
        qd0(:,1) double
        tplan(1,1) double
        tfinal(1,1) double
        base_params(1,:) cell
        param_range(:,2) double
        time_zonos(1,:) cell
    end

    num_q = length(q0);
    num_t = length(time_zonos);

    for i = num_q:-1:1
        param{i} = 0.5 * (base_params{i} + 1) * (param_range(i,2) - param_range(i,1)) + param_range(i,1);
    end

    % Compute key constants
    stopping_time = tfinal - tplan;

    % Peak values (first part of the traj)
    for i=num_q:-1:1
        qpeak{i} = q0(i) + qd0(i)*tplan + 0.5*param{i}*(tplan^2);
        qdpeak{i} = qd0(i) + param{i}*tplan;
    end

    % Braking values (second part of the traj)
    for i=num_q:-1:1
        stopping_qdd{i} = (-1) * qdpeak{i} * (1.0/stopping_time);
        final_q{i} = qpeak{i} + qdpeak{i}*stopping_time + 0.5*stopping_qdd{i}*(stopping_time^2);
    end

    % Create the trajectory
    q_ref = num2cell(zeros(num_t, num_q));
    qd_ref = q_ref;
    qdd_ref = q_ref;
    for idx_t=1:num_t
        t = time_zonos{idx_t};
        if t.c <= tplan
            for i=num_q:-1:1
                q_ref{idx_t, i} = q0(i) + qd0(i).*t + 0.5*param{i}.*(t.*t);
                qd_ref{idx_t, i} = qd0(i) + param{i}.*t;
                qdd_ref{idx_t, i} = param{i};
            end
        elseif t.c <= tfinal
            for i=num_q:-1:1
                tshift = (t-tplan);
                q_ref{idx_t, i} = qpeak{i} + qdpeak{i}.*tshift + 0.5*stopping_qdd{i}.*(tshift.*tshift);
                qd_ref{idx_t, i} = qdpeak{i} + stopping_qdd{i}.*(tshift);
                qdd_ref{idx_t, i} = stopping_qdd{i};
            end
        else
            for i=num_q:-1:1
                q_ref{idx_t, i} = final_q{i};
            end
        end
    end
end
