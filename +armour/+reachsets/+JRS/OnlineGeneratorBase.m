classdef OnlineGeneratorBase < rtd.planner.reachsets.ReachSetGenerator
% Base class for online generation of joint reachable sets used in ARMOUR.
%
% This class is used to generate joint reachable sets for ARMOUR. The
% reachable sets are generated online and are based on some reference
% trajectory. The reference trajectory is provided as a cell array of
% polynomial zonotops. This cell array is of size n_t x n_q where n_t is
% the number of time steps and n_q is the number of joints. Each cell
% contains a polynomial zonotope for the desired joint position, velocity,
% or acceleration respectively.
%
% The reachable sets are generated by taking the reference trajectory and
% adding a zonotope for the tracking error (if provided).
%
% See BernsteinJRSGen for an example where the number of parameters is
% equal to the number of joints, and TwoBernsteinJRSGen for an example
% where the number of parameters is not equal to the number of joints.
%
% This incorporates methods previously found in create_jrs_online.m written
% by Patrick Holmes.
%
% --- More Info ---
% Author: Adam Li (adamli@umich.edu)
% Written: 2022-10-01
% Updated: 2023-10-04 (Adam Li)
%
% See also: armour.reachsets.JRS.JRSInstance, armour.reachsets.JRS.BernsteinJRSGen,
% armour.reachsets.JRS.TwoBernsteinJRSGen, armour.reachsets.JRS.PiecewiseJRSGen,
% rtd.planner.reachsets.ReachSetGenerator
%
% --- Revision History ---
% 2023-10-04 - Renamed from JRSGenerator. create_jrs_online is now merged into this.
%
% --- More Info ---
%

    % Required Abstract Properties
    properties
        % This is the maximum number of reachable sets that can be stored
        % in the cache. If the cache is full, the oldest reachable set will
        % be removed.
        cache_max_size = 1
    end

    % Additional Properties
    properties (GetAccess=public, SetAccess=protected)
        % The number of time steps in the reference trajectory
        num_t(1,1) double {mustBeInteger}
        % The time duration the reference trajectory should be considered active in
        tplan(1,1) double
        % The final time of the reference trajectory and when the braking action should be complete
        tfinal(1,1) double
        % The time discretization of the reference trajectory
        tdiscretization(1,1) double
        % Whether to use unique id's for each time step
        use_unique_tid(1,1) logical
        % The time zonotopes (generated in makeBaseZonos)
        time_zonos(1,:) cell

        % The number of joints in the robot
        num_joints(1,1) double {mustBeInteger}
        % A map of id's to their respective dimensions
        id_map(1,1) struct

        % The number of parameters in the trajectory parameterization
        num_params(1,1) double {mustBeInteger}
        % The parameter zonotopes (generated in makeBaseZonos)
        % These are always zero centered and with a radius of 1
        param_zonos(1,:) cell
        % The center of the parameter value
        param_center(:,1) double
        % The range of the parameter value
        param_extents(:,1) double
        % The id's/dimensions of the parameters
        param_ids(1,:) double {mustBeInteger}
        
        % Whether to add the ultimate bound to the reachable sets
        add_ultimate_bound(1,1) logical
        % The ultimate bound of the controller
        ultimate_bound(:,1) double
        % The K_r gain of the controller
        k_r(:,1) double
        % The tracking error zonotopes (generated in makeBaseZonos)
        error_pos_zonos(1,:) cell
        % The tracking error zonotopes (generated in makeBaseZonos)
        error_vel_zonos(1,:) cell

        % The degree of the taylor approximation used to generate the
        % final rotatotopes
        taylor_degree(1,1) double {mustBeInteger}
        % The axes of the joints
        joint_axes(3,:) double
    end

    % Public Methods
    methods
        function self = OnlineGeneratorBase(robot, options)
            % Constructor for the OnlineGeneratorBase class.
            %
            % Arguments:
            %   robot (armour.Agent): The robot to generate reachable sets for
            %   options: Keyword Arguments. See below.
            %
            % Keyword Arguments:
            %   taylor_degree (int): The degree of the taylor approximation
            %       used to generate the final rotatotopes. Default: 1
            %   add_ultimate_bound (bool): Whether to add the ultimate
            %       bound to the reachable sets. Default: true
            %   verboseLevel (rtd.util.types.LogLevel): The verbose level
            %       for logging. Default: DEBUG
            %   param_center (double): The center of the parameter value.
            %       Default: 0
            %   param_range (double): The range of the parameter value.
            %       Default: pi/36
            %   tplan (double): The time duration the reference trajectory
            %       should be considered active in. Default: 0.5
            %   tfinal (double): The final time of the reference trajectory
            %       and when the braking action should be complete.
            %       Default: 1
            %   use_unique_tid (bool): Whether to use unique id's for each
            %       time step. Default: false
            %   tdiscretization (double): The time discretization of the
            %       reference trajectory. Default: 0.01
            %
            arguments
                robot armour.ArmourAgent
                options.taylor_degree(1,1) double {mustBeInteger} = 1
                options.add_ultimate_bound(1,1) logical = true
                options.verboseLevel(1,1) rtd.util.types.LogLevel = "DEBUG"
                options.param_center(:,1) double = 0
                options.param_range(:,1) double = pi/36
                options.tplan(1,1) double = 0.5
                options.tfinal(1,1) double = 1
                options.use_unique_tid(1,1) logical = false
                options.tdiscretization(1,1) double = 0.01
            end
            
            % Set the verbose level for logging
            self.set_vdisplevel(options.verboseLevel);

            % Pull some general parameters
            self.joint_axes = [robot.info.joints.axes];
            self.taylor_degree = options.taylor_degree;
            self.num_joints = robot.info.num_q;

            % Save the optimization parameter range
            self.param_center = options.param_center;
            self.param_extents = options.param_range;
            
            % Save the time parameters
            self.tplan = options.tplan;
            self.tfinal = options.tfinal;
            self.tdiscretization = options.tdiscretization;
            self.num_t = ceil(self.tfinal/self.tdiscretization);
            self.use_unique_tid = options.use_unique_tid;

            % Save the ultimate bound parameters (if relevant)
            self.add_ultimate_bound = options.add_ultimate_bound;
            self.ultimate_bound = [];
            self.k_r = [];
            if self.add_ultimate_bound
                try
                    self.ultimate_bound = ones(self.num_joints, 1).*robot.controller.ultimate_bound(:);
                    self.k_r = ones(self.num_joints, 1).*robot.controller.Kr(:);
                catch
                    self.vdisp("Ultimate bound not found! Not adding!", "WARN")
                    self.add_ultimate_bound = false;
                    self.ultimate_bound = [];
                    self.k_r = [];
                end
            end

            % Make the base zonotopes
            self.makeBaseZonos();
        end
    end

    % Key class methods
    methods (Access=protected)
        function jrs_instance = createInstanceFromReference(self, q_ref, qd_ref, qdd_ref, extras)
            % Create a JRSInstance from a reference trajectory.
            %
            % Arguments:
            %   q_ref (cell): The reference joint positions in an n_t x n_q
            %       cell array where n_t is the number of time steps and
            %       n_q is the number of joints.
            %   qd_ref (cell): The reference joint velocities in an n_t x
            %       n_q cell array.
            %   qdd_ref (cell): The reference joint accelerations in an n_t
            %       x n_q cell array.
            %   extras: Keyword Arguments. See below.
            %
            % Keyword Arguments:
            %   independent_nonparam_gens (bool): Whether to make the
            %       generators that don't correspond to optimization parameters
            %       independent. Default: true
            %
            % Returns:
            %   jrs_instance (armour.reachsets.JRS.JRSInstance): The
            %       generated JRSInstance
            %
            arguments
                self(1,1) armour.reachsets.JRS.OnlineGeneratorBase
                q_ref cell
                qd_ref cell
                qdd_ref cell
                extras.independent_nonparam_gens(1,1) logical = true
            end

            % Generate the reference rotatotopes
            self.vdisp("Creating Reference Rotations!", "DEBUG")
            for t_idx=self.num_t:-1:1
                for i=self.num_joints:-1:1
                    [R_ref{t_idx, i}, ~] = armour.pz_roahm.get_pz_rotations_from_q(q_ref{t_idx, i}, self.joint_axes(:,i), self.taylor_degree);
                end
            end

            % Add tracking error if provided
            if ~(isempty(self.error_pos_zonos) || isempty(self.error_vel_zonos))
                self.vdisp("Adding Tracking Error!", "DEBUG")
                for t_idx=self.num_t:-1:1
                    for i=self.num_joints:-1:1
                        q{t_idx, i} = q_ref{t_idx, i} + self.error_pos_zonos{i};
                        qd{t_idx, i} = qd_ref{t_idx, i} + self.error_vel_zonos{i};
                        qd_aux{t_idx, i} = qd_ref{t_idx, i} + self.k_r(i)*self.error_pos_zonos{i};
                        qdd_aux{t_idx, i} = qdd_ref{t_idx, i} + self.k_r(i)*self.error_vel_zonos{i};
                        [R{t_idx, i}, ~] = armour.pz_roahm.get_pz_rotations_from_q(q{t_idx, i}, self.joint_axes(:,i), self.taylor_degree);
                    end
                end
            end

            % Make independence if requested
            if extras.independent_nonparam_gens
                self.vdisp("Making extra generators independent!", "DEBUG")
                for t_idx=self.num_t:-1:1
                    for i=self.num_joints:-1:1
                        q_ref{t_idx, i} = remove_dependence_and_compress(q_ref{t_idx, i}, self.param_ids);
                        qd_ref{t_idx, i} = remove_dependence_and_compress(qd_ref{t_idx, i}, self.param_ids);
                        qdd_ref{t_idx, i} = remove_dependence_and_compress(qdd_ref{t_idx, i}, self.param_ids);
                        R_ref{t_idx, i} = remove_dependence_and_compress_mat(R_ref{t_idx, i}, self.param_ids);
                        R_t_ref{t_idx, i} = R_ref{t_idx, i}.';
                    end
                end
                if ~(isempty(self.error_pos_zonos) || isempty(self.error_vel_zonos))
                    for t_idx=self.num_t:-1:1
                        for i=self.num_joints:-1:1
                            q{t_idx, i} = remove_dependence_and_compress(q{t_idx, i}, self.param_ids);
                            qd{t_idx, i} = remove_dependence_and_compress(qd{t_idx, i}, self.param_ids);
                            qd_aux{t_idx, i} = remove_dependence_and_compress(qd_aux{t_idx, i}, self.param_ids);
                            qdd_aux{t_idx, i} = remove_dependence_and_compress(qdd_aux{t_idx, i}, self.param_ids);
                            R{t_idx, i} = remove_dependence_and_compress_mat(R{t_idx, i}, self.param_ids);
                            R_t{t_idx, i} = R{t_idx, i}.';
                        end
                    end
                end
            else
                self.vdisp('Treating time and tracking error as dependent generators. Make sure to remove them before creating constraints.', 'INFO')
            end

            % Filler if we don't have error
            if (isempty(self.error_pos_zonos) || isempty(self.error_vel_zonos))
                q = q_ref;
                qd = qd_ref;
                qd_aux = qd_ref;
                qdd_aux = qdd_ref;
                R = R_ref;
            end

            % Save all the values
            jrs_instance = armour.reachsets.JRS.JRSInstance;
            % Split into column cells of column cells for compat
            % Rest of the code expects the JRS in this form.
            jrs_instance.q_des = num2cell(q_ref.', 1).';
            jrs_instance.dq_des = num2cell(qd_ref.', 1).';
            jrs_instance.ddq_des = num2cell(qdd_ref.', 1).';
            jrs_instance.q = num2cell(q.', 1).';
            jrs_instance.dq = num2cell(qd.', 1).';
            jrs_instance.dq_a = num2cell(qd_aux.', 1).';
            jrs_instance.ddq_a = num2cell(qdd_aux.', 1).';
            jrs_instance.R_des = num2cell(R_ref.', 1).';
            jrs_instance.R_t_des = num2cell(R_t_ref.', 1).';
            jrs_instance.R = num2cell(R.', 1).';
            jrs_instance.R_t = num2cell(R_t.', 1).';

            jrs_instance.n_q = self.num_joints;
            jrs_instance.num_parameters = self.num_params;
            jrs_instance.n_t = self.num_t;
            jrs_instance.k_id = self.param_ids;
            jrs_instance.setParamRange([self.param_center - self.param_extents, self.param_center + self.param_extents]);
        end

        function makeBaseZonos(self, options)
            % Make the base zonotopes based on the number of params given.
            %
            % Arguments:
            %   options: Keyword Arguments. See below.
            %
            % Keyword Arguments:
            %   num_params (int): The number of parameters. Default: self.num_joints
            %
            arguments
                self(1,1) armour.reachsets.JRS.OnlineGeneratorBase
                options.num_params(1,1) uint32 = self.num_joints
            end
    
            % Ensure the size of the param_center and param_extents match
            self.num_params = options.num_params;
            self.param_center = ones(options.num_params, 1).*self.param_center;
            self.param_extents = ones(options.num_params, 1).*self.param_extents;
    
            % Record of what id's are associated to what values
            self.id_map = struct;
    
            % Create base PZ's for parameters
            self.param_zonos = cell(1, self.num_params);
            self.param_ids = 1:self.num_params;
            for i = 1:self.num_params
                % Make the base pz
                self.param_zonos{i} = armour.pz_roahm.polyZonotope_ROAHM(0, 1, [], 1, self.param_ids(i));
                % Add its id to the map
                self.id_map.(sprintf('k%d', i)) = self.param_ids(i);
            end
    
            % Create the base PZ's for time
            self.time_zonos = cell(1, self.num_t);
            if self.use_unique_tid
                t_id = length(fieldnames(self.id_map)) + 1:self.num_t;
            else
                t_id = length(fieldnames(self.id_map)) + 1;
                self.id_map.('t') = t_id;
            end
            for i = 1:self.num_t
                % Make the base pz
                self.time_zonos{i} = armour.pz_roahm.polyZonotope_ROAHM(self.tdiscretization*(i-1)+self.tdiscretization/2, self.tdiscretization/2, [], 1, t_id);
                if self.use_unique_tid
                    self.id_map.(sprintf('t%d', i)) = t_id(i);
                end
            end
    
            % Create PZ's for error
            if ~(isempty(self.ultimate_bound) && isempty(self.k_r))
                self.error_pos_zonos = cell(1,self.num_joints);
                self.error_vel_zonos = cell(1,self.num_joints);
                for i = 1:self.num_joints
                    e_id = length(fieldnames(self.id_map)) + 1;
                    self.error_pos_zonos{i} = armour.pz_roahm.polyZonotope_ROAHM(0, self.ultimate_bound(i)/self.k_r(i), [], 1, e_id);
                    self.id_map.(sprintf('e_pos%d', i)) = e_id;
                    self.error_vel_zonos{i} = armour.pz_roahm.polyZonotope_ROAHM(0, 2*self.ultimate_bound(i), [], 1, e_id+1);
                    self.id_map.(sprintf('e_vel%d', i)) = e_id+1;
                end
            end
        end
    end
end

% Make the specified id's the only dependent generators and turn the rest
% to independents
function B = remove_dependence_and_compress(A, k_id)
import armour.pz_roahm.*
	k_id_idx = any(A.id == k_id(:).', 2);
	k_slc_idx = (any(A.expMat(k_id_idx, :) ~= 0, 1) & all(A.expMat(~k_id_idx, :) == 0, 1)); % should only be one!
	if length(find(k_slc_idx)) > sum(k_id_idx)
		error('There should only be one fully-k-sliceable generator');
	end
	B = polyZonotope_ROAHM(A.c, A.G(k_slc_idx), sum(abs(A.G(~k_slc_idx))) + sum(abs(A.Grest)), A.expMat(k_id_idx, k_slc_idx), A.id(k_id_idx));
	% B = polyZonotope_ROAHM(A.c, A.G(k_slc_idx), [A.G(~k_slc_idx), A.Grest], A.expMat(k_id_idx, k_slc_idx), k_id);
end

% Same as above but for matPolyZonotopes
function B = remove_dependence_and_compress_mat(A, k_id)
import armour.pz_roahm.*
	k_id_idx = any(A.id == k_id(:).', 2);
	k_slc_idx = (any(A.expMat(k_id_idx, :) ~= 0, 1) & all(A.expMat(~k_id_idx, :) == 0, 1)); % should only be one!
% 	if length(find(k_slc_idx)) > 1
% 		error('There should only be one fully-k-sliceable generator');
% 	end
	B = matPolyZonotope_ROAHM(A.C, A.G(:, :, k_slc_idx), cat(3, A.G(:, :, ~k_slc_idx), A.Grest), A.expMat(k_id_idx, k_slc_idx), A.id(k_id_idx));
end